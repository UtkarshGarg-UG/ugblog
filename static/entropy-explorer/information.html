<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Binary Guessing Demo (iframe-ready)</title>
<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
<style>
  :root {
    --bg: #ffffff;
    --fg: #111827;
    --muted: #6b7280;
    --ring: #e5e7eb;
    --accent: #10b981;
    --accent-soft: #a7f3d0;
    --bar-off: #e5e7eb;
  }
  html, body {
    background: var(--bg);
    color: var(--fg);
    margin: 0;
    padding: 0;
    font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  }
  .wrap {
    display: grid;
    grid-template-columns: 1fr;
    gap: 12px;
    padding: 12px;
    box-sizing: border-box;
    max-width: 1100px;
    margin: 0 auto;
  }
  .controls {
    display: grid;
    grid-template-columns: 1fr 1fr auto auto auto;
    gap: 10px;
    align-items: end;
  }
  .field {
    display: grid;
    grid-template-columns: 100px 1fr 80px;
    gap: 8px;
    align-items: center;
  }
  .field label { font-size: 13px; color: var(--muted); }
  input[type="range"] { width: 100%; }
  input[type="number"] {
    width: 100%;
    padding: 6px 8px;
    border: 1px solid var(--ring);
    border-radius: 8px;
    font-size: 14px;
  }
  button {
    padding: 8px 12px;
    border: 1px solid var(--ring);
    background: #fff;
    border-radius: 10px;
    cursor: pointer;
    font-size: 14px;
  }
  button:active { transform: translateY(1px); }
  .panel {
    display: grid;
    grid-template-columns: 2fr 1fr;
    gap: 12px;
  }
  #chart {
    width: 100%;
    height: 560px; /* chart area only; controls are outside */
    border: 1px solid var(--ring);
    border-radius: 12px;
  }
  .info {
    border: 1px solid var(--ring);
    border-radius: 12px;
    padding: 12px;
    display: grid;
    gap: 8px;
    align-content: start;
    min-height: 120px;
  }
  .info h3 {
    margin: 0 0 4px 0; font-size: 16px;
  }
  .k {
    font-size: 13px; color: var(--muted);
  }
  .bits {
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    font-size: 14px;
    background: #f9fafb;
    border: 1px dashed var(--ring);
    border-radius: 8px;
    padding: 6px 8px;
    word-break: break-word;
  }
  .footer {
    font-size: 12px; color: var(--muted);
    text-align: right;
  }
  @media (max-width: 900px) {
    .panel { grid-template-columns: 1fr; }
    #chart { height: 520px; }
    .controls { grid-template-columns: 1fr; }
    .field { grid-template-columns: 80px 1fr 80px; }
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="controls">
    <div class="field">
      <label for="nRange">N</label>
      <input id="nRange" type="range" min="2" max="128" step="1" value="8" />
      <input id="nInput" type="number" min="2" max="128" step="1" value="8" />
    </div>
    <div class="field">
      <label for="tRange">Target</label>
      <input id="tRange" type="range" min="1" max="8" step="1" value="3" />
      <input id="tInput" type="number" min="1" max="8" step="1" value="3" />
    </div>

    <button id="playBtn">▶ Play</button>
    <button id="pauseBtn">⏸ Pause</button>
    <button id="resetBtn">↺ Reset</button>
  </div>

  <div class="panel">
    <div id="chart"></div>
    <div class="info" id="infoPanel">
      <h3>Binary Questions</h3>
      <div class="k" id="titleText">Guessing a Number</div>
      <div id="qText">Question: —</div>
      <div id="aText">Answer: —</div>
      <div class="bits" id="bitsText">Bits so far: —</div>
      <div class="k">Legend: Yes → 0, No → 1</div>
      <div class="k" id="capText">ceil(log₂ N): —</div>
    </div>
  </div>

  <div class="footer">
    Play / Pause / Reset controls are separate from the chart for clean embedding.
  </div>
</div>

<script>
    (function () {
      // Elements
      const nRange = document.getElementById('nRange');
      const nInput = document.getElementById('nInput');
      const tRange = document.getElementById('tRange');
      const tInput = document.getElementById('tInput');
      const playBtn = document.getElementById('playBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const resetBtn = document.getElementById('resetBtn');
      const chartEl = document.getElementById('chart');
    
      const qText = document.getElementById('qText');
      const aText = document.getElementById('aText');
      const bitsText = document.getElementById('bitsText');
      const capText = document.getElementById('capText');
      const titleText = document.getElementById('titleText');
    
      // State
      let N = 8;
      let target = 3;
      let steps = [];
      let stepIndex = 0; // 0 = initial state
      let timer = null;
      const FRAME_MS = 800;
    
      // Helpers
      function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
      function bitsCeil(n) { return Math.ceil(Math.log2(n)); }
    
      function computeSteps(N, target) {
        const s = [];
        let L = 1, R = N;
        while (L < R) {
          const mid = Math.floor((L + R) / 2);
          if (target <= mid) {
            R = mid; s.push({ L, R, mid, answer: "Yes", bit: 0 });
          } else {
            L = mid + 1; s.push({ L, R, mid, answer: "No", bit: 1 });
          }
        }
        return s;
      }
    
      function colorsForInterval(N, L, R, reveal, target) {
        const arr = new Array(N).fill('#E5E7EB'); // light gray
        for (let i = L - 1; i <= R - 1; i++) arr[i] = '#A7F3D0'; // active
        if (reveal) arr[target - 1] = '#10B981'; // final
        return arr;
      }
    
      // Build figure
      async function initFigure() {
        const cap = bitsCeil(N);
    
        // x positions and bars
        const x = Array.from({ length: N }, (_, i) => i + 1);
        const initColors = colorsForInterval(N, 1, N, false, target);
        const initMid = steps.length ? steps[0].mid : target;
    
        const barTrace = {
          x, y: new Array(N).fill(1),
          type: 'bar',
          marker: { color: initColors },
          hovertemplate: 'Value %{x}<extra></extra>',
          xaxis: 'x', yaxis: 'y',
          showlegend: false
        };
    
        const midLine = {
          x: [initMid, initMid],
          y: [0, 1.05],
          mode: 'lines',
          line: { dash: 'dash' },
          hoverinfo: 'skip',
          xaxis: 'x', yaxis: 'y',
          showlegend: false
        };
    
        const questionsLine = {
          x: [0], y: [0],
          mode: 'lines+markers',
          name: 'Questions used',
          hovertemplate: 'Step %{x}<extra></extra>',
          xaxis: 'x2', yaxis: 'y2'
        };
    
        const capLine = {
          x: [0, cap], y: [cap, cap],
          mode: 'lines',
          line: { dash: 'dash' },
          name: `ceil(log₂ N) = ${cap}`,
          hoverinfo: 'skip',
          xaxis: 'x2', yaxis: 'y2'
        };
    
        const layout = {
          grid: { rows: 2, columns: 1, pattern: 'independent', roworder: 'top to bottom' },
          height: 560,
          margin: { l: 50, r: 10, t: 30, b: 40 },
    
          xaxis:  { title: 'Value', range: [0.5, N + 0.5], dtick: 1 },
          yaxis:  { visible: false, range: [0, 1.1] },
    
          xaxis2: { title: 'Bits (questions)', range: [-0.1, Math.max(cap, steps.length) + 0.1] },
          yaxis2: { title: 'Count', range: [0, Math.max(cap, steps.length) + 0.8] },
    
          showlegend: true,
          legend: { orientation: 'h', x: 1, xanchor: 'right', y: -0.15 }
        };
    
        await Plotly.newPlot(chartEl, [barTrace, midLine, questionsLine, capLine], layout, {
          displayModeBar: false, responsive: true
        });
      }
    
      function updateInfo(stepIdx) {
        const cap = bitsCeil(N);
        titleText.textContent = `Guessing a Number (N=${N}, hidden=${target})`;
        capText.textContent = `ceil(log₂ N): ${cap}`;
    
        if (stepIdx === 0) {
          const initMid = steps.length ? steps[0].mid : target;
          qText.textContent = `Question 1: Is it ≤ ${initMid}?`;
          aText.textContent = `Answer: (press Play)`;
          bitsText.textContent = `Bits so far: —`;
          return;
        }
    
        const t = stepIdx;
        const s = steps[t - 1];
        const sofar = steps.slice(0, t).map(x => x.bit).join('');
        qText.textContent = `Question ${t}: Is it ≤ ${s.mid}?`;
        aText.textContent = `Answer: ${s.answer}`;
        bitsText.textContent = `Bits so far: ${sofar}`;
      }
    
      async function drawStep(stepIdx) {
        const cap = bitsCeil(N);
    
        if (stepIdx === 0) {
          const initMid = steps.length ? steps[0].mid : target;
    
          // Trace 0: bars
          await Plotly.restyle(chartEl, { 'marker.color': [colorsForInterval(N, 1, N, false, target)] }, [0]);
    
          // Trace 1: mid line
          await Plotly.restyle(chartEl, { x: [[initMid, initMid]], y: [[0, 1.05]] }, [1]);
    
          // Trace 2: questions line
          await Plotly.restyle(chartEl, { x: [[0]], y: [[0]] }, [2]);
    
          // Trace 3: cap line
          await Plotly.restyle(chartEl, { x: [[0, cap]], y: [[cap, cap]] }, [3]);
    
          updateInfo(0);
          return;
        }
    
        const t = stepIdx;
        const S = steps[t - 1];
        const reveal = (t === steps.length) && (S.L === S.R);
        const colors = colorsForInterval(N, S.L, S.R, reveal, target);
    
        const xs = Array.from({ length: t + 1 }, (_, i) => i);
        const ys = xs.slice(); // y = x
    
        // Trace 0: bars
        await Plotly.restyle(chartEl, { 'marker.color': [colors] }, [0]);
    
        // Trace 1: mid line
        await Plotly.restyle(chartEl, { x: [[S.mid, S.mid]], y: [[0, 1.05]] }, [1]);
    
        // Trace 2: questions line
        await Plotly.restyle(chartEl, { x: [xs], y: [ys] }, [2]);
    
        // Trace 3: cap line (cap can change if N changed between runs)
        await Plotly.restyle(chartEl, { x: [[0, cap]], y: [[cap, cap]] }, [3]);
    
        updateInfo(stepIdx);
      }
    
      function stopTimer() {
        if (timer) { clearInterval(timer); timer = null; }
      }
    
      function startTimer() {
        stopTimer();
        timer = setInterval(() => {
          if (stepIndex >= steps.length) { stopTimer(); return; }
          stepIndex += 1;
          drawStep(stepIndex);
        }, FRAME_MS);
      }
    
      function rebuild() {
        // Validate inputs
        N = clamp(parseInt(nInput.value || '8', 10), 2, 128);
        nInput.value = N; nRange.value = N;
    
        // Adjust target constraints
        tRange.max = String(N);
        tInput.max = String(N);
        target = clamp(parseInt(tInput.value || '1', 10), 1, N);
        tRange.value = target; tInput.value = target;
    
        // Compute steps and reset state
        steps = computeSteps(N, target);
        stepIndex = 0;
        stopTimer();
    
        initFigure().then(() => {
          drawStep(0);
        });
      }
    
      // Input wiring (sync sliders/inputs)
      function syncN(from) {
        const val = clamp(parseInt(from.value || '8', 10), 2, 128);
        nRange.value = val; nInput.value = val;
        if (parseInt(tInput.value || '1', 10) > val) {
          tInput.value = val; tRange.value = val;
        }
        rebuild();
      }
      function syncT(from) {
        const maxT = parseInt(nInput.value || '8', 10);
        const val = clamp(parseInt(from.value || '1', 10), 1, maxT);
        tRange.value = val; tInput.value = val;
        rebuild();
      }
    
      nRange.addEventListener('input', e => syncN(e.target));
      nInput.addEventListener('change', e => syncN(e.target));
    
      tRange.addEventListener('input', e => syncT(e.target));
      tInput.addEventListener('change', e => syncT(e.target));
    
      playBtn.addEventListener('click', () => {
        if (stepIndex >= steps.length) stepIndex = 0;
        startTimer();
      });
      pauseBtn.addEventListener('click', () => stopTimer());
      resetBtn.addEventListener('click', () => {
        stopTimer();
        stepIndex = 0;
        drawStep(0);
      });
    
      // First render
      rebuild();
    })();
    </script>
    
</body>
</html>
